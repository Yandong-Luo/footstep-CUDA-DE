# import numpy as np

# np.set_printoptions(threshold=np.inf, precision=6, suppress=True)

# # 定义矩阵 D (50x1)
# D = np.array([0.518370, 0.585255, 3.901861, 5.020326, 0.845929, 0.967649, 1.156522, 
#              4.637585, 5.882935, 0.874081, 1.375974, 1.688110, 3.280005, 4.520342, 
#              0.886917, 1.594215, 2.038698, 1.036706, 2.486008, 0.907142, 1.591695, 
#              2.200290, -0.964606, 0.884318, 0.944536, 1.438071, 2.250700, -1.878772, 
#              0.318334, 1.002233, 1.264941, 2.300803, -1.345858, 0.837540, 1.068120, 
#              1.207192, 2.436567, 0.306157, 1.885578, 1.110797, 1.324073, 2.655854, 
#              1.858718, 2.247999, 1.108310, 1.500000, 2.800000, 1.000000, 0.000000, 
#              1.078987]).reshape(50, 1)

# # 定义矩阵 E (50x5)
# E = np.zeros((50, 5))
# E_data = [
#     [1.000000, 0.000000, 0.513166, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 0.513166, 0.000000],
#     [0.000000, 0.000000, 1.892976, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 1.892976, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
#     [1.000000, 0.000000, 1.484576, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 1.484576, 0.000000],
#     [0.000000, 0.000000, 3.583357, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 3.583357, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
#     [1.000000, 0.000000, 3.323433, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 3.323433, 0.000000],
#     [0.000000, 0.000000, 6.783209, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 6.783209, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
#     [1.000000, 0.000000, 6.804344, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 6.804344, 0.000000],
#     [0.000000, 0.000000, 12.840450, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 12.840450, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
#     [1.000000, 0.000000, 13.393624, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 13.393624, 0.000000],
#     [0.000000, 0.000000, 24.306662, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 24.306662, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
#     [1.000000, 0.000000, 25.866974, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 25.866974, 0.000000],
#     [0.000000, 0.000000, 46.011921, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 46.011921, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
#     [1.000000, 0.000000, 49.478722, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 49.478722, 0.000000],
#     [0.000000, 0.000000, 87.099457, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 87.099457, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
#     [1.000000, 0.000000, 94.175186, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 94.175186, 0.000000],
#     [0.000000, 0.000000, 164.877167, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 164.877167, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
#     [1.000000, 0.000000, 178.784515, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 178.784515, 0.000000],
#     [0.000000, 0.000000, 312.108490, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 312.108490, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000],
#     [1.000000, 0.000000, 338.947937, 0.000000, 0.000000],
#     [0.000000, 1.000000, 0.000000, 338.947937, 0.000000],
#     [0.000000, 0.000000, 590.813843, 0.000000, 0.000000],
#     [0.000000, 0.000000, 0.000000, 590.813843, 0.000000],
#     [0.000000, 0.000000, 0.000000, 0.000000, 1.000000]
# ]

# for i in range(50):
#     E[i] = E_data[i]

# # Define x_0 (make sure it's shaped correctly)
# x_0 = np.array([0.29357406, 0.29125562, -0.01193462, -0.01774755, 1.58432257]).reshape(5, 1)

# # Calculate E@x_0
# E_x_0 = E @ x_0  # This should be 50x1

# # Print shapes to verify
# print("D shape:", D.shape)
# print("E shape:", E.shape)
# print("x_0 shape:", x_0.shape)
# print("E@x_0 shape:", E_x_0.shape)

# # Calculate D - E@x_0
# result = D - E_x_0  # This should be 50x1

# print("Result shape:", result.shape)
# print("\nD - E@x_0 result:")
# print(result)

# # # Print row by row
# # print("\nRow-by-row results:")
# # for i in range(50):
# #     print(f"[{i}]: {result[i, 0]:.8f}")


# import numpy as np
# import numpy as np

# # 读取文件
# file_path = "./tmp.txt"  # 请替换为你的文件路径
# with open(file_path, "r") as f:
#     data = [list(map(float, line.split())) for line in f]

# # 转换为 NumPy 矩阵
# bigF = np.array(data)

# # 打印或使用矩阵
# print(bigF)


# # # Define matrix bigF
# # bigF = np.array([
# #     [-0.892976, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, -0.892976, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [-5.034157, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, -5.034157, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [-3.476333, 0.000000, 0.000000, -0.892976, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, -3.476333, 0.000000, 0.000000, -0.892976, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [-9.529538, 0.000000, 0.000000, -5.034157, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, -9.529538, 0.000000, 0.000000, -5.034157, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [-8.366567, 0.000000, 0.000000, -3.476333, 0.000000, 0.000000, -0.892976, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, -8.366567, 0.000000, 0.000000, -3.476333, 0.000000, 0.000000, -0.892976, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [-18.039185, 0.000000, 0.000000, -9.529538, 0.000000, 0.000000, -5.034157, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, -18.039185, 0.000000, 0.000000, -9.529538, 0.000000, 0.000000, -5.034157, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [-17.623661, 0.000000, 0.000000, -8.366567, 0.000000, 0.000000, -3.476333, 0.000000, 0.000000, -0.892976, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, -17.623661, 0.000000, 0.000000, -8.366567, 0.000000, 0.000000, -3.476333, 0.000000, 0.000000, -0.892976, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [-34.147739, 0.000000, 0.000000, -18.039185, 0.000000, 0.000000, -9.529538, 0.000000, 0.000000, -5.034157, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, -34.147739, 0.000000, 0.000000, -18.039185, 0.000000, 0.000000, -9.529538, 0.000000, 0.000000, -5.034157, 0.000000, 0.000000, 0.000000, 0.000000],
# #     [0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000],
# #     [-35.147114, 0.000000, 0.000000, -17.623661, 0.000000, 0.000000, -8.366567, 0.000000, 0.000000, -3.476333, 0.000000, 0.000000, -0.892976, 0.000000, 0.000000],
# #     [0.000000, -35.147114, 0.000000, 0.000000, -17.623661, 0.000000, 0.000000, -8.366567, 0.000000, 0.000000, -3.476333, 0.000000, 0.000000, -0.892976, 0.000000],
# #     [-64.640846, 0.000000, 0.000000, -34.147739, 0.000000, 0.000000, -18.039185, 0.000000, 0.000000, -9.529538, 0.000000, 0.000000, -5.034157, 0.000000, 0.000000],
# #     [0.000000, -64.640846, 0.000000, 0.000000, -34.147739, 0.000000, 0.000000, -18.039185, 0.000000, 0.000000, -9.529538, 0.000000, 0.000000, -5.034157, 0.000000],
# #     [0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000]
# # ])

# # Reshape into a 25x15 matrix (25 rows, 15 columns)
# # bigF = np.array(bigF_flat).reshape(25, 15)

# # print(np.dot(bigF.T, bigF))

# # # Define vector D
# # D = np.array([0.287450, 0.282148, -0.022592, -0.033596, 1.584323,
# #               0.275856, 0.264908, -0.042766, -0.063596, 1.584323,
# #               0.253910, 0.232273, -0.080955, -0.120385, 1.584323,
# #               0.212367, 0.170495, -0.153246, -0.227887, 1.584323,
# #               0.133726, 0.053552, -0.290091, -0.431384, 1.584323,
# #               -0.015138, -0.167820, -0.549135, -0.816599, 1.584323,
# #               -0.296936, -0.586870, -1.039499, -1.545802, 1.584323,
# #               -0.830371, -1.380123, -1.967746, -2.926166, 1.584323,
# #               -1.840151, -2.881731, -3.724896, -5.539161, 1.584323,
# #               -3.751641, -5.724240, -7.051139, -10.485497, 1.584323,
# #               -7.370045, -11.105039, -13.347636, -19.848795, 1.584323,
# #               -14.219594, -21.290760, -25.266750, -37.573288, 1.584323,
# #               -27.185627, -40.572086, -47.829350, -71.125320, 1.584323,
# #               -51.730019, -77.071182, -90.539803, -134.638519, 1.584323,
# #               -98.191956, -146.163055, -171.389648, -254.867462, 1.584323,
# #               -186.143250, -276.952332, -324.436462, -482.457947, 1.584323,
# #               -352.632965, -524.533264, -614.150391, -913.281189, 1.584323,
# #               -667.793945, -993.197998, -1162.571777, -1728.819092, 1.584323,
# #               -1264.386108, -1880.368896, -2200.720215, -3272.612793, 1.584323,
# #               -2393.720459, -3559.761719, -4165.910156, -6194.976562, 1.584323,
# #               -4531.522949, -6738.812500, -7885.967285, -11726.941406, 1.584323,
# #               -8578.332031, -12756.678711, -14927.945312, -22198.816406, 1.584323,
# #               -16238.842773, -24148.351562, -28258.238281, -42021.820312, 1.584323,
# #               -30740.007812, -45712.511719, -53492.160156, -79546.289062, 1.584323,
# #               -58190.355469, -86532.953125, -101259.367188, -150579.203125, 1.584323,
# #               -110153.195312, -163805.046875, -191681.531250, -285042.781250, 1.584323,
# #               -208517.625000, -310079.281250, -362848.500000, -539579.125000, 1.584323,
# #               -394719.093750, -586972.812500, -686863.437500, -1021410.125000, 1.584323,
# #               -747193.875000, -1111125.625000, -1300215.875000, -1933504.750000, 1.584323,
# #               -1414420.250000, -2103334.250000, -2461277.250000, -3660077.750000, 1.584323])

# D = np.array([0.014739, -0.011488, 0.548302, -1.150766, -0.816258, 0.052462, -0.050327, 1.078915, -2.082006, -1.395999,
#     0.116880, -0.102309, 1.584960, -2.775650, -1.792570, 0.215608, -0.146611, 2.070279, -3.205218, -2.049374,
#     0.364153, -0.150093, 2.556025, -3.325722, -2.201310, 0.593389, -0.056436, 3.093299, -3.054582, -2.276085,
#     0.963596, 0.234517, 3.787246, -2.235488, -2.295420, 1.590957, 0.905951, 4.842826, -0.570037, -2.276134,
#     2.697642, 2.298339, 6.651647, 2.511685, -2.231119, 4.706531, 5.050118, 9.956481, 8.096054, -2.170195,
#     8.420461, 10.364042, 16.162886, 18.249598, -2.100856, 15.361470, 20.511497, 27.929234, 36.896725, -2.028889,
#     28.412928, 39.787209, 50.283833, 71.481224, -1.958895, 53.035011, 76.316589, 92.739731, 136.111450, -1.894679,
#     99.565506, 145.477005, 173.298203, 257.514038, -1.839533, 187.575180, 276.374451, 326.027435, 486.304199, -1.796405,
#     354.112427, 524.103577, 615.408813, 918.319763, -1.767948, 669.309753, 992.955566, 1163.494385, 1735.006836, -1.756455,
#     1265.927124, 1880.350830, 2201.315918, 3279.867920, -1.763683, 2395.276123, 3560.001709, 4166.199707, 6203.176270, -1.790558,
#     4533.083496, 6739.339355, 7885.983887, 11735.918945, -1.836764, 8579.889648, 12757.514648, 14927.734375, 22208.359375, -1.900223,
#     16240.389648, 24149.511719, 28257.855469, 42031.664062, -1.976449, 30741.541016, 45714.000000, 53491.671875, 79556.125000, -2.057802,
#     58191.871094, 86534.765625, 101258.851562, 150588.656250, -2.132610, 110154.695312, 163807.156250, 191681.078125, 285051.437500, -2.184191,
#     208519.109375, 310081.656250, 362848.187500, 539586.500000, -2.189749, 394720.562500, 586975.437500, 686863.375000, 1021415.687500, -2.119160,
#     747195.375000, 1111128.375000, 1300216.125000, 1933507.875000, -1.933646, 1414421.750000, 2103337.000000, 2461278.000000, 3660077.750000, -1.584323])


# # Solve the linear system bigF*u=D using least squares (in case the system is overdetermined)
# u, residuals, rank, s = np.linalg.lstsq(bigF, D, rcond=None)

# print("Solution for u:")
# for i, val in enumerate(u):
#     print(f"u[{i}] = {val}")

# # Check the solution by computing bigF*u and comparing with D
# result = np.dot(bigF, u)
# print("\nVerification - bigF*u:")
# for i, (computed, original) in enumerate(zip(result, D)):
#     print(f"Row {i}: Computed: {computed:.6f}, Original D: {original:.6f}, Diff: {abs(computed-original):.6f}")

# print("\nNorm of difference (should be close to zero):", np.linalg.norm(result - D))


import numpy as np

state_data = [
    0.293574, 0.291256, -0.011935, -0.017747, 1.584323, 
    0.297224, 0.326533, 0.230192, 2.037569, 0.923296, 
    0.308880, 0.420998, 0.468663, 3.544300, 0.467463, 
    0.328436, 0.557448, 0.704154, 4.567521, 0.184974, 
    0.355783, 0.720846, 0.935895, 5.171908, 0.046167, 
    0.390765, 0.898297, 1.161897, 5.421197, 0.023578, 
    0.433146, 1.079006, 1.379174, 5.377656, 0.091938, 
    0.482572, 1.254224, 1.583967, 5.101543, 0.228183, 
    0.538557, 1.417168, 1.771971, 4.650577, 0.411441, 
    0.600465, 1.562928, 1.938556, 4.079398, 0.623024, 
    0.667503, 1.688360, 2.078991, 3.439039, 0.846413, 
    0.738723, 1.791951, 2.188671, 2.776391, 1.067237, 
    0.813026, 1.873676, 2.263338, 2.133656, 1.273247, 
    0.889182, 1.934829, 2.299305, 1.547829, 1.454287, 
    0.965850, 1.977847, 2.293685, 1.050156, 1.602255, 
    1.041611, 2.006099, 2.244607, 0.665598, 1.711064, 
    1.115000, 2.023681, 2.151448, 0.412295, 1.776597, 
    1.184560, 2.035167, 2.015049, 0.301040, 1.796655, 
    1.248884, 2.045364, 1.837949, 0.334733, 1.770901, 
    1.306686, 2.059035, 1.624598, 0.507856, 1.700797, 
    1.356860, 2.080613, 1.381592, 0.805932, 1.589544, 
    1.398561, 2.113890, 1.117887, 1.204995, 1.442002, 
    1.431283, 2.161694, 0.845030, 1.671050, 1.264621, 
    1.454953, 2.225547, 0.577381, 2.159544, 1.065357, 
    1.470025, 2.305299, 0.332334, 2.614827, 0.853584, 
    1.477588, 2.398756, 0.130548, 2.969618, 0.640006, 
    1.479476, 2.501279, -0.003836, 3.144476, 0.436555, 
    1.478389, 2.605370, -0.042968, 3.047257, 0.256298, 
    1.478022, 2.700241, 0.044937, 2.572585, 0.113321, 
    1.483194, 2.771363, 0.295819, 1.601315, 0.022624, 
    1.500000, 2.800000, 0.750000, 0.000000, 0.000000
]

state = np.array(state_data).reshape(-1, 1)

def create_block_diagonal_E(n_blocks=30):
    # 基础E矩阵
    E = np.array([
        [1, 0, 0.513166, 0, 0],
        [0, 1, 0, 0.513166, 0],
        [0, 0, 1.89298, 0, 0],
        [0, 0, 0, 1.89298, 0],
        [0, 0, 0, 0, 1]
    ])
    
    # 计算大矩阵的尺寸
    rows_per_block = E.shape[0]
    cols_per_block = E.shape[1]
    total_rows = n_blocks * rows_per_block
    total_cols = n_blocks * cols_per_block
    
    # 创建空矩阵
    bigE = np.zeros((total_rows, total_cols))
    
    # 填充块对角结构
    for i in range(n_blocks):
        row_start = i * rows_per_block
        col_start = i * cols_per_block
        bigE[row_start:row_start+rows_per_block, col_start:col_start+cols_per_block] = E
    
    return bigE

# print("state - Ex0", state - Ex0)

E = np.array([
    [1, 0, 0.513166, 0, 0],
    [0, 1, 0, 0.513166, 0],
    [0, 0, 1.89298, 0, 0],
    [0, 0, 0, 1.89298, 0],
    [0, 0, 0, 0, 1]
])

F = np.array([
    [-0.892976, -0, 0],
    [-0, -0.892976, 0],
    [-5.03416, -0, 0],
    [-0, -5.03416, 0],
    [0, 0, 1]
])

u = np.array([0.119504,-0.0237862,0.122125])

init_state = np.array([0.29357406,  0.29125562, -0.0, -0.0,  1.58432257])

print(np.dot(E, init_state)+np.dot(F, u))

next_state = np.array([ 0.375229, 0.336478, -0.0,  0.0,  1.70644757])

F_inv = np.array([
        [-0.034161, 0.000000, -0.192583, 0.000000, 0.000000],
        [0.000000, -0.034161, 0.000000, -0.192583, 0.000000],
        [0.000000, 0.000000, 0.000000, 0.000000, 1.000000]
    ])

tmp_D = next_state - np.dot(E, init_state)
print(np.dot(F_inv, tmp_D))

# # 示例：创建30个块的对角矩阵
# diagE = create_block_diagonal_E(30)

# # print(diagE)
# # print(state[5:10] - np.dot(E, state[:5]))
# D = state[5:] - np.dot(diagE, state[:-5])
# # print(state[5:] - np.dot(diagE, state[:-5]))

# tmp_D = state[5:10] - np.dot(E, state[:5])





# # Create the matrix D based on the provided data
# D = np.array([
#     [0.035483, 0.059999, 1.724168, 2.954601, -0.114498],
#     [0.126504, 0.211625, 3.039310, 5.072330, -0.320819],
#     [0.264462, 0.435465, 3.982926, 6.467541, -0.581434],
#     [0.446171, 0.721990, 4.604982, 7.266229, -0.866211],
#     [0.677897, 1.077345, 4.973836, 7.615113, -1.151521],
#     [0.982851, 1.534266, 5.188239, 7.699733, -1.419416],
#     [1.415241, 2.172769, 5.400761, 7.779564, -1.656846],
#     [2.086743, 3.159321, 5.862927, 8.255396, -1.854953],
#     [3.216550, 4.821067, 7.011382, 9.797728, -2.008408],
#     [5.226033, 7.786425, 9.631771, 13.590742, -2.114821],
#     [8.917901, 13.251330, 15.169696, 21.794970, -2.174194],
#     [15.815345, 23.483400, 26.320097, 38.424023, -2.188443],
#     [28.804037, 42.776478, 48.143723, 71.005089, -2.160976],
#     [53.347466, 79.257767, 90.181290, 133.723129, -2.096329],
#     [99.787560, 148.308838, 170.456299, 253.373581, -1.999856],
#     [187.699860, 279.042053, 323.053040, 480.631561, -1.877485],
#     [354.137970, 526.560181, 612.462341, 911.385193, -1.735525],
#     [669.239807, 995.164307, 1160.738403, 1727.119751, -1.580538],
#     [1265.770752, 1882.285400, 2198.906738, 3271.365479, -1.419265],
#     [2395.047119, 3561.647461, 4164.279297, 6194.410156, -1.258609],
#     [4532.800293, 6740.693359, 7884.669434, 11727.241211, -1.105681],
#     [8579.573242, 12758.585938, 14927.109375, 22200.109375, -0.967902],
#     [16240.065430, 24150.318359, 28257.958984, 42024.152344, -0.853162],
#     [30741.230469, 45714.574219, 53492.488281, 79549.609375, -0.770039],
#     [58191.601562, 86535.140625, 101260.289062, 150583.343750, -0.728077],
#     [110154.476562, 163807.375000, 191682.968750, 285047.437500, -0.738116],
#     [208518.968750, 310081.781250, 362850.281250, 539583.812500, -0.812695],
#     [394720.500000, 586975.437500, 686865.312500, 1021414.187500, -0.966494],
#     [747195.312500, 1111128.375000, 1300217.500000, 1933507.375000, -1.216849],
#     [1414421.750000, 2103337.000000, 2461278.000000, 3660077.750000, -1.584323]
# ])

# Function to create the block diagonal matrix with the F_inv pattern
def create_bigF_inverse(n_blocks=30):
    # The F_inv block (3x5 matrix)
    F_inv = np.array([
        [-0.034161, 0.000000, -0.192583, 0.000000, 0.000000],
        [0.000000, -0.034161, 0.000000, -0.192583, 0.000000],
        [0.000000, 0.000000, 0.000000, 0.000000, 1.000000]
    ])
    
    # Size of the full matrix
    rows_per_block = F_inv.shape[0]
    cols_per_block = F_inv.shape[1]
    total_rows = n_blocks * rows_per_block
    total_cols = n_blocks * cols_per_block
    
    # Create empty matrix
    bigF_inverse = np.zeros((total_rows, total_cols))
    
    # Fill in the block diagonal structure
    for i in range(n_blocks):
        row_start = i * rows_per_block
        col_start = i * cols_per_block
        bigF_inverse[row_start:row_start+rows_per_block, col_start:col_start+cols_per_block] = F_inv
    
    return bigF_inverse

# # Create the matrix
# bigF_inverse = create_bigF_inverse()
# D = D.reshape(-1, 1)
# print("F_inv * D", np.dot(bigF_inverse, D))

# Print the matrix shape
# print(f"Matrix D shape: {D.shape}")
